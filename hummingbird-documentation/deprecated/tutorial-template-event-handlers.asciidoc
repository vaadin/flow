ifdef::env-github[:outfilesuffix: .asciidoc]
= Handling User Events in a AngularTemplate

== Client Side Event Handlers
AngularTemplate defines a special syntax `(event-name)="javascriptCode"` for attaching client side event handlers to elements:

[source,html]
----
<button (click)="window.alert('Hello');">Say hello</button>
----

Clicking on the `<button>` will now show an alert in the browser. You can listen to any event using the `(event-name)` syntax, it does not matter if it is a built-in browser event or a custom event from e.g. a web component.

There are a few special variables available when the event handler is executed: `$event`, `$element` and `$server`. The `$event` variable refers to the JavaScript event object, the `$element` variable refers to the element for which the handler was defined. `$server` is described for in detail in <<Server Side Event Handlers>> below.

[NOTE]
The `$element` variable refers to the element for which the event handler was defined, not the target element of the event. If you have a click handler on an element and click on a child element, `$element` will refer to the parent element and `$event.target` will refer to the child (clicked) element.

== Server Side Event Handlers
To handle a DOM event in a template on the server side, you have two options:

1. Use a client side listener which calls the server, e.g. `(event)=$server.myEventHandler(myParameters)` to invoke the `myEventHandler` method in the server side `AngularTemplate` class.
2. Find a reference to the element in the server `AngularTemplate` class and attach a listener. This is similar to what is done in <<tutorial-event-listener#,Listening to User Events>>

=== Event Listener in the HTML Template
In the following template a click listener is attached to the button and the event handler calls the `sayHello` method on the server:

[source,html]
----
<div>
  <input id="name" />
  <button (click)="$server.sayHello(name.value)">Say hello</button>
  <span>{{helloText}}</span>
</div>
----

[NOTE]
We can use `name.value` because the `<input>` element has `id="name"` and the browser makes these elements available in the global namespace using their id.

The server side template class defines the published `sayHello` method using the `@ClientDelegate` annotation:

[source,java]
----
public class MyTemplate extends AngularTemplate {
  public interface MyModel extends TemplateModel {
      public void setHelloText(String helloText);
  }
  @Override
  public MyModel getModel() {
      return (MyModel) super.getModel();
  }

  @ClientDelegate
  private void sayHello(String name) {
    getModel().setHelloText("Hello " + name);
  }
}
----

The `sayHello` method is invoked whenever `$server.sayHello` is called on the client side and the given parameters will be passed to the method on the server. In this case the event handler updates the template model so that a "Hello <name>" message is shown.

[NOTE]
Only `String`, `int`, `Integer`, `double`, `Double`, `boolean`, `Boolean`, `JsonValue` and arrays of all those types are supported parameter types.
[NOTE]
The `@ClientDelegate` method can have any access modifier (`private`/`protected`/`public`) but must return `void`.
[NOTE]
The `$server` variable is only available in template event handlers.

=== Event Listener in the Server Side Java Class
If you use a server side event listener, you can use the same template as above but without any listener code:

[source,html]
----
<div>
  <input id="name" />
  <button id="button">Say hello</button>
  <span>{{helloText}}</span>
</div>
----

The server side `AngularTemplate` will instead map the `<button>` element to a `Button` component and add a click listener to it:

[source,java]
----
public class MyTemplate extends AngularTemplate {
  public interface MyModel extends TemplateModel {
      public void setHelloText(String helloText);
  }
  @Override
  public MyModel getModel() {
      return (MyModel) super.getModel();
  }

  @Id("button")
  private Button button;
  @Id("name")
  private Input name;

  public MyTemplate() {
    button.addClickListener(e->{
      getModel().setHelloText("Hello " + name.getValue());
    });
  }
}
----

The `@Id` annotation is used here to map a component to an element defined in the template with an appropriate identifier.
See <<tutorial-template-components#,Adding Components to a AngularTemplate>> for the details.
