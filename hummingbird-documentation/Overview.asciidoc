ifdef::env-github[:outfilesuffix: .asciidoc]
= Hummingbird
:toc:
== Product overview

Hummingbird is a Java framework for building interactive web sites.
The heart of Hummingbird will consist of three ways of interacting with the DOM in the user's web browser:

 1. HTML-based templates that are bound to server-side Model data.
 1. A server-side representation of the client-side DOM tree.
 1. A type-safe Java RPC API for interacting with JavaScript in the browser.

These mechanisms are intended to be encapsulated into reusable components with a high-level Java API.

The current version only implements the DOM tree and beginnings of the RPC mechanism.

== Tutorials

These tutorials show how the different features are used.

* Application structure
** <<tutorial-hello-world#,Hello World>>
** <<tutorial-include-css#,Including Style Sheets>>
* Element API
** <<tutorial-properties-attributes#,Element Properties and Attributes>>
** <<tutorial-event-listener#,Listening to User Events>>
** <<tutorial-user-input#,Retrieving User Input>>
** <<tutorial-dynamic-styling#,Dynamic styling>>
* Misc
** <<tutorial-history-api#,The History API>>

The rest of this document gives a high-level overview of the features and explains how they fit together.

== Server-side DOM tree

Tutorials: <<tutorial-properties-attributes#,Element Properties and Attributes>>, <<tutorial-event-listener#,Listening to User Events>>, <<tutorial-user-input#,Retrieving User Input>>,  <<tutorial-dynamic-styling#,Dynamic styling>>

Hummingbird allows Java code to control the DOM in the user's browser through a server-side representation of the same DOM tree.
All changes are automatically synchronized to the real DOM tree in the browser.

The DOM tree is built up from `Element` instances, each one representing a DOM element in the browser.
The root of the server-side DOM tree is the `Element` of the `UI` instance, accessible using `ui.getElement()`.
This element represents the `<body>` tag.

Elements on the server are implemented as flyweight instances.
This means that you can usually not use `==` and `!=` checking element identity.
Instead, `element.equals(otherElement)` should be used to check whether two instances refer to the same DOM element in the browser.

=== Element hierarchy

A web application is structured as a tree of elements with the root being the element of the `UI` instance. An element can be added as a child of another element using methods such as `element.appendChild(Element)` for adding an element to the end of a parent's child list or `element.insertChild(int, Element)` for adding to any position in the child list.

The element hierarchy can be navigated upwards using `element.getParent()` and downwards using `element.getChildCount()` and `element.getChild(int)`.

== Executing JavaScript

There are cases where it's not enough to manipulate the client-side DOM tree only using child elements, attributes and properties.
These can be handled with the help of a server-side Java API for invoking arbitrary JavaScript in the browser: `ui.getPage().executeJavaScript(String, Object...)`. The JavaScript will be executed in the browser after the DOM tree in the browser has been updated based on changes from the server.

Along with the JavaScript expression to execute, parameters of various types can also be passed.
The provided parameter values will be available to the script as variables named `$0`, `$1` and so on. Supported parameter types are `String`, `Boolean`, `Integer`, `Double`, `JsonValue` and `Element`. An element instance will be passed as `null` if the element is not attached to the DOM on the server when the changes are sent to the browser.

As a practical example, this snippet will show the dimensions of the given element in the browser console: `ui.getPage().executeJavaScript("console.log($1, $0.offsetWidth, $0.offsetHeight)", element, "Element dimensions:")`.

== History API

Tutorial: <<tutorial-history-api#,The History API>>

The _History API_ allows you to access the browser navigation history. As the history is
always web page specific, you can access it through `ui.getPage().getHistory()`.
The API allows you to:

* programmatically traverse the history
* modify the history by adding a new entry or replacing the current entry
* listen to user originated history traversal events from browser
