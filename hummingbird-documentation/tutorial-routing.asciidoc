ifdef::env-github[:outfilesuffix: .asciidoc]

== Defining View Routes
The _Routing API_ allows you to define a mapping between _URLs_ and _Views_ and handles navigation between _Views_ without page reloads. Routes are specified on a service (servlet) level, i.e. the configuration is shared between all users. You can define your own `RouterConfigurator` class which provides the configuration using the `@VaadinServletConfiguration` annotation.

[source,java]
----
@WebServlet(urlPatterns = "/*", name = "MyServlet", asyncSupported = true)
@VaadinServletConfiguration(routerConfigurator = MyRouterConfigurator.class, productionMode = false)
public static class MyServlet extends VaadinServlet {
}
----

Your `RouterConfigurator` class needs to override one method, where the actual configuration takes place. You cannot modify the configuration outside this method or store the configuration instance for later use. This is make sure that the configuration is thread safe.

[source,java]
----
@Override
public void configure(RouterConfiguration configuration) {
  configuration.setRoute("", HomeView.class);
  configuration.setRoute("company", CompanyView.class);
}
----

This will set up routing so that `HomeView` is used when the base URL (servlet path) is opened, e.g. `http://mysite.com/` and  `CompanyView` is used when `/company` is opened, e.g. using `http://mysite.com/company`.

[NOTE]
Do not start routes with a `/` as the URLs are relative to the servlet path.

All views must implement the `View` interface and override one method: `getElement()`. This method must return the root element of the view and cannot be changed while the view is visible. The HomeView class could thus look like:
[source,java]
----
public class HomeView implements View {

    private Element element;

    public HomeView() {
        element = ElementFactory.createDiv("This is the home view");
    }

    @Override
    public Element getElement() {
        return element;
    }
}
----

== Navigating Between Views

You can use the `RouterLink` component to create links that lead to different views in the location.

[source,java]
----
Div menu = new Div();
menu.add(new RouterLink("Home", HomeView.class));
menu.add(new RouterLink("Company", CompanyView.class));
----

It is of course also possible to navigate with normal `<a href="company">` type links but these will cause a page reload.
Navigation with `RouterLink` only triggers a server visit to fetch the contents of the new view, which is updated in place without reloading the page.

[TIP]
By adding a `routerlink` attribute to a regular link, you tell the framework that it should handle navigation without reloads, e.g. `<a routerlink href="company">Go to the company page</a>`.

To trigger navigation from the server side, use `UI.navigateTo(String)`, where the string parameter is the location to navigate to, e.g. to navigate to the `company` view when clicking a button:

[source,java]
----
Element button = ElementFactory.createButton("Navigate to company");
button.addEventListener("click", e-> {
    UI.getCurrent().navigateTo("company");
});
----

[NOTE]
Router links will work even if the session has expired so you should prefer to use those instead of handling navigation server side.

See also:

* <<tutorial-routing-view-hierarchy#,View Hierarchy and Nested Views>>
* <<tutorial-routing-view-parameters#,Using View Parameters>>
* <<tutorial-routing-view-titles#,Updating Page Title on Navigation>>
