ifdef::env-github[:outfilesuffix: .asciidoc]

== Defining View Routes
The _Routing API_ allows you to define a mapping between _URLs_ and _Views_ and handles navigation between _Views_ without page reloads. Routes are specified on a service (servlet) level, i.e. the configuration is shared between all users. You can define your own `RouterConfigurator` class which provides the configuration using the `@VaadinServletConfiguration` annotation.

[source,java]
----
@WebServlet(urlPatterns = "/*", name = "MyServlet", asyncSupported = true)
@VaadinServletConfiguration(routerConfigurator = MyRouterConfigurator.class, productionMode = false)
public static class MyServlet extends VaadinServlet {
}
----

Your `RouterConfigurator` class needs to override one method, where the actual configuration takes place. You cannot modify the configuration outside this method or store the configuration instance for later use. This is make sure that the configuration is thread safe.

[source,java]
----
@Override
public void configure(RouterConfiguration configuration) {
  configuration.setRoute("", HomeView.class);
  configuration.setRoute("company", CompanyView.class);
}
----

This will set up routing so that `HomeView` is used when the base URL (servlet path) is opened, e.g. `http://mysite.com/` and  `CompanyView` is used when `/company` is opened, e.g. using `http://mysite.com/company`.

[NOTE]
Do not start routes with a `/` as the URLs are relative to the servlet path.

All views must implement the `View` interface and override one method: `getElement()`. This method must return the root element of the view and cannot be changed while the view is visible. You can extend some existing component class which already has this method. The HomeView class could thus look like:
[source,java]
----
public class HomeView extends Div implements View {

    public HomeView() {
        setText("This is the home view");
    }

}
----

== Navigating Between Views

To navigate between views you can use standard `<a href="company">` type links but these will cause a page reload. By adding a `routerlink` attribute to the link, you tell the framework that it should handle navigation without reloads, e.g. `<a routerlink href="company">Go to the company page</a>`. This way navigation only triggers a server visit to fetch the contents of the new view.

Using Java you can create router links using the helper method `ElementFactory.createRouterLink(String href, String textContent)`.

To trigger navigation from the server side, use `UI.navigateTo(String)`, where the string parameter is the location to navigate to, e.g. to navigate to the `company` view when clicking a button:

[source,java]
----
Button button = new Button("Navigate to company");
button.addClickListener( e-> {
     button.getUI().ifPresent(ui -> ui.navigateTo("company"));
});
----

[NOTE]
Router links will work even if the session has expired so you should prefer to use those instead of handling navigation server side.

See also:

* <<tutorial-routing-view-hierarchy#,View Hierarchy and Nested Views>>
* <<tutorial-routing-view-parameters#,Using View Parameters>>
* <<tutorial-routing-view-titles#,Updating Page Title on Navigation>>
