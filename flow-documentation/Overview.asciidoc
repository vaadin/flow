ifdef::env-github[:outfilesuffix: .asciidoc]
= Flow
:toc:
== Product overview

Flow is a Java framework for building interactive web sites.
The heart of Flow will consist of three ways of interacting with the DOM in the user's web browser:

 1. HTML-based templates that are bound to server-side Model data.
 1. A server-side representation of the client-side DOM tree.
 1. A type-safe Java RPC API for interacting with JavaScript in the browser.

These mechanisms are intended to be encapsulated into reusable components with a high-level Java API.

The current version provides a complete DOM tree implementation and beginnings of the mechanisms for both templates and RPC.

== Tutorials

These tutorials show how the different features are used.

* Application structure
** <<tutorial-hello-world#,Hello World>>
** <<tutorial-include-css#,Including Style Sheets>>
** <<tutorial-importing#,Importing html/javascript>>
** <<tutorial-ways-of-importing#,Ways of importing the dependencies>>
** <<tutorial-dependency-filter#,Modifying how dependencies are loaded with DependencyFilters>>
** <<tutorial-bootstrap#,Modifying bootstrap page>>
* Element API
** <<tutorial-properties-attributes#,Element Properties and Attributes>>
** <<tutorial-event-listener#,Listening to User Events>>
** <<tutorial-user-input#,Retrieving User Input>>
** <<tutorial-dynamic-styling#,Dynamic styling>>
** <<tutorial-shadow-root#,Shadow root in server-side Element>>
* Web components
** <<tutorial-webcomponent-basic#,Basic Integration of a Polymer Web Component>>
** <<tutorial-webcomponent-attributes-and-properties#,Using Attributes and Properties with a Polymer Web Component>>
** <<tutorial-webcomponent-events#,Using Events with a Polymer Web Component>>
** <<tutorial-webcomponents-es5#,Serving ES5 Web Components to older browsers with Polymer 2>>
* Flow components
** <<tutorial-flow-components-setup#,Setup your project to use Flow components>>
** Binding Data to Forms
*** <<tutorial-flow-components-binder#,Binder overview>>
*** <<tutorial-flow-components-binder-validation#,Validating and Converting User Input>>
*** <<tutorial-flow-components-binder-load#,Loading from and Saving to Business Objects>>
*** <<tutorial-flow-components-binder-beans#,Binding Beans to Forms>>
* Creating your own components
** <<tutorial-component-basic#,Creating A Simple Component Using the Element API>>
** <<tutorial-component-many-elements#,Creating a Component Based on Many Elements>>
** <<tutorial-component-property-descriptor#,Using API Helpers for Defining Component Properties>>
** <<tutorial-component-composite#,Creating a Component Using Existing Components>>
** <<tutorial-component-events#,Using Events with Components>>
** <<tutorial-component-container#,Creating a Component Which Can Contain Other Components>>
** <<tutorial-component-with-dependencies#,Creating a Component with External Dependencies>>
* Routing and navigation
** <<tutorial-routing-annotation#,Defining Routes with @Route>>
** <<tutorial-routing-lifecycle#,Navigation Lifecycle>>
** <<tutorial-routing-navigation#,Navigating Between Routes>>
** <<tutorial-routing-router-configuration#,Defining View Routes with RouterConfiguration>>
** <<tutorial-router-layout#,Router Layouts and Nested Router Targets>>
** <<tutorial-routing-view-hierarchy#,View Hierarchy and Nested Views>>
** <<tutorial-routing-view-parameters#,Using View Parameters>>
** <<tutorial-routing-view-titles#,Updating Page Title on Navigation>>
** <<tutorial-routing-error-view#,Defining an Error View>>
** <<tutorial-routing-rerouting#,Rerouting to another View>>
* Polymer template
** <<tutorial-template-basic#,Creating A Simple Component Using the Template API>>
** <<tutorial-template-components#,Binding Components from PolymerTemplate>>
** <<tutorial-template-subtemplate#,Using sub-template from PolymerTemplate>>
** <<tutorial-template-components-in-slot#,Using <slot> in PolymerTemplates>>
** <<tutorial-template-event-handlers#,Handling User Events in a PolymerTemplate>>
** <<tutorial-template-bindings#,Binding Model Data in a PolymerTemplate>>
*** <<tutorial-template-bindings#two-way-binding,Two-way data binding>>
*** <<tutorial-template-list-bindings#,Using List of Items in a PolymerTemplate with template repeater>>
** <<tutorial-template-model-bean#,Using Beans with a PolymerTemplate Model>>
** <<tutorial-template-model-converters#,Using Model Converters with a PolymerTemplate Model>>
* Misc
** <<tutorial-execute-javascript#,Executing JavaScript>>
** <<tutorial-history-api#,The History API>>
** <<tutorial-dynamic-content#,Dynamic Content>>
** <<tutorial-loading-indicator#,The Loading Indicator>>

The rest of this document gives a high-level overview of the features and explains how they fit together.

== Server-side DOM tree

Tutorials: <<tutorial-properties-attributes#,Element Properties and Attributes>>, <<tutorial-event-listener#,Listening to User Events>>, <<tutorial-user-input#,Retrieving User Input>>,  <<tutorial-dynamic-styling#,Dynamic styling>>

Flow allows Java code to control the DOM in the user's browser through a server-side representation of the same DOM tree.
All changes are automatically synchronized to the real DOM tree in the browser.

The DOM tree is built up from `Element` instances, each one representing a DOM element in the browser.
The root of the server-side DOM tree is the `Element` of the `UI` instance, accessible using `ui.getElement()`.
This element represents the `<body>` tag.

Elements on the server are implemented as flyweight instances.
This means that you cannot compare elements using `==` and `!=`.
Instead, `element.equals(otherElement)` should be used to check whether two instances refer to the same DOM element in the browser.

=== Element Hierarchy

A web application is structured as a tree of elements with the root being the element of the `UI` instance. An element can be added as a child of another element using methods such as `element.appendChild(Element)` for adding an element to the end of a parent's child list or `element.insertChild(int, Element)` for adding to any position in the child list.

The element hierarchy can be navigated upwards using `element.getParent()` and downwards using `element.getChildCount()` and `element.getChild(int)`.

=== Component Hierarchy
The component hierarchy provides an higher level abstraction on top of the element hierarchy. A component consists of a root element and can optionally contain any number of child elements. Components can be added inside other components using methods such as `UI.add(Component)`, provided the parent component supports child components.

Composite is a special kind of component which does not have a root element of its own but instead encapsulates another component. The main use case for a composite is to combine existing components into new components while hiding the original component API.

The component hierarchy can be navigated upwards using `component.getParent()` and downwards using `component.getChildren()`. The component hierarchy is constructed based on the element hierarchy, so they are always in sync.

== Templates
Instead of writing Java code for building the DOM from individual elements, it's also possible to use the `Template` component to define the overall DOM structure in an HTML template file and then use a model to control the contents of the elements.

In addition to giving a clearer overview of the structure of a Component, the template functionality does also help improve performance â€“
the same template definition is reused for all component instance using the same template file. This means that less memory is used on the server and less data needs to be sent to the browser.

== History API

Tutorial: <<tutorial-history-api#,The History API>>

The _History API_ allows you to access the browser navigation history through `ui.getPage().getHistory()`.
The API allows you to:

* Programmatically traverse the history.
* Modify the history by adding a new entry or replacing the current entry.
* Listen to user originated history traversal events from the browser.
