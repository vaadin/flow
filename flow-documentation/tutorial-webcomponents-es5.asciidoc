ifdef::env-github[:outfilesuffix: .asciidoc]
= Serving ECMAScript 5 webcomponents with Polymer 2

According to the native custom element specification, ECMAScript 6 is required
to define webcomponents. But when deploying an application to IE11 and Safari 9,
 you need to compile the files to ECMAScript 5 (ES5 for short), since those
browsers don't support ECMAScript 6. Luckily there's a library that can compile
and optimize the ES6 files to ES5, which is provided by the Polymer project:
polymer-build.

[TIP]
The same library can also be used to optimize ES6 scripts, by using minification.

== Project structure

To ease the process of compiling your project, you should avoid placing your
webcomponents at `src/main/webapp` or any other source directory. The source files
won't be used by the project, just the compiled ones.

The suggested project structure, which complies to the Maven standards, is the
following:

* project-root/
** src/main/
*** java/ - Your Java code
*** webapp/ - Static files not associated to webcomponents (such as images, favicon,
  files for download and so on)
*** frontend/ - Root path of your webcomponents
** src/test/java/ - Your tests
** target/ - Your output directory
** pom.xml - Your project definition Maven file

=== Javascript dependencies

In your `src/main/frontend` directory, you have to create 4 files:

==== package.json

This file defines the core versions of bower, gulp and polymer-build packages,
and what to run when the packages have been installed. Once created, you don't have
to change this file anymore.

[source,json]
----
{
  "name": "polymer-build",
  "version": "1.0.0",
  "main": "",
  "dependencies": {
    "bower": "^1.8.0",
    "gulp": "^3.9.1",
    "polymer-cli": "next"
  },
  "scripts": {
    "install": "bower install && polymer build"
  }
}
----

==== bower.json

This file defines the webcomponent dependencies you have in your project. Keep
this file updated every time you make changes in your javascript dependencies,
just like you do in your `pom.xml` with Java dependencies.

[source,json]
----
{
  "name": "my-project",
  "description": "",
  "main": "",
  "private": true,
  "ignore": [
    "**/.*",
    "node_modules",
    "bower_components",
    "test",
    "tests"
  ],
  "dependencies": {
    "polymer": "Polymer/polymer#v2.0.0-rc.7",
    "other-dependency" : "version"
  }
}
----

[NOTE]
The most important dependency in this file is the Polymer version.

==== polymer.json

This file defines how the project will be built. Here is where you set the
compilation parameters. The entire structure of the file is described
https://www.polymer-project.org/2.0/docs/tools/polymer-json[here].

[source,json]
----
{
  "entrypoint": "index.html",
  "sources": [
   "bower.json"
  ],
  "extraDependencies": [
    "bower_components/webcomponentsjs/webcomponents-lite.js"
  ],
  "builds": [{
    "name": "es5",
    "js": {"compile": true, "minify": true},
    "css": {"minify": true},
    "html": {"minify": true}
  },
  {
    "name": "es6",
    "js": {"minify": true},
    "css": {"minify": true},
    "html": {"minify": true}
  }]
}
----

[NOTE]
Change the `minify` property to `false` if you want to skip minification of your
files.

==== index.html

For pure Polymer applications without Flow, this file would be the entry point of
the application. Since in Flow the entrypoint is generated by the framework, this
file is used just to link to the other webcomponents, so the compiler can build
the dependency tree and properly optimize the code.

In this file you only add your own dependencies, using HTML imports:

[source,xml]
----
<!-- Assuming your files are located at src/main/frontend/components -->
<link rel="import" href="components/my-component1.html">
<link rel="import" href="components/my-component2.html">
----

[WARNING]
When creating a new component, don't forget to declare its dependencies at the
`bower.json` file and the component location at the `index.html`.

In summary, the distribution of files inside `src/main/frontend` should be:

* src/main/frontend/
** bower.json
** package.json
** polymer.json
** index.html
** components/ -> that's where you put your webcomponents

== Using Maven plugins to compile your project

Once properly structured, the project can be compiled using regular Maven
commands, such as `mvn package`.

To do so, you need to add specific configuration to your `pom.xml` file. This
configuration is a one-time setup. You can copy-paste the example below it
directly to your `pom.xml`.

[TIP]
This configuration also prepares your project to properly run with the Maven
Jetty Plugin, by using the `mvn jetty:run` command.

[source,xml]
----
<properties>
  <jetty.version>9.3.7.v20160115</jetty.version>
  <vaadin.frontend.path>VAADIN/static/frontend</vaadin.frontend.path>
</properties>

<build>
  <plugins>
      <plugin> <!--1-->
          <groupId>org.apache.maven.plugins</groupId>
          <artifactId>maven-war-plugin</artifactId>
          <version>3.0.0</version>
          <configuration>
              <webResources>
                  <resource>
                      <directory>src/main/frontend/build</directory>
                      <targetPath>${vaadin.frontend.path}</targetPath>
                  </resource>
              </webResources>
          </configuration>
      </plugin>

      <plugin> <!--2-->
          <artifactId>maven-resources-plugin</artifactId>
          <version>3.0.2</version>
          <executions>
              <execution>
                  <id>copy-resources</id>
                  <phase>process-resources</phase>
                  <goals>
                      <goal>copy-resources</goal>
                  </goals>
                  <configuration>
                      <outputDirectory>${project.build.directory}/jetty-extra-resources/${vaadin.frontend.path}</outputDirectory>
                      <overwrite>true</overwrite>
                      <resources>
                          <resource>
                              <directory>${project.basedir}/src/main/frontend/build</directory>
                          </resource>
                      </resources>
                  </configuration>
              </execution>
          </executions>
      </plugin>

      <plugin> <!--3-->
          <groupId>org.eclipse.jetty</groupId>
          <artifactId>jetty-maven-plugin</artifactId>
          <version>${jetty.version}</version>
          <configuration>
              <webAppConfig>
                  <webInfIncludeJarPattern>.*/flow-.*.jar$|.*/test-resources-.*.jar$</webInfIncludeJarPattern>
                  <containerIncludeJarPattern>^$</containerIncludeJarPattern>
                  <resourceBases>
                      <resourceBase>${project.basedir}/src/main/webapp</resourceBase>
                      <resourceBase>${project.build.directory}/jetty-extra-resources</resourceBase>
                  </resourceBases>
              </webAppConfig>
          </configuration>
      </plugin>
  </plugins>
</build>

<profiles>
  <profile>
    <id>frontend-files</id>
    <activation>
        <property>
            <name>!skip.bower</name>
        </property>
    </activation>
    <build>
        <plugins>
            <plugin> <!--4-->
                <groupId>com.github.eirslett</groupId>
                <artifactId>frontend-maven-plugin</artifactId>
                <version>1.4</version>
                <configuration>
                    <nodeVersion>v6.9.1</nodeVersion>
                    <yarnVersion>v0.22.0</yarnVersion>
                    <workingDirectory>src/main/frontend</workingDirectory>
                </configuration>
                <executions>
                    <execution>
                        <phase>generate-resources</phase>
                        <id>install node and yarn</id>
                        <goals>
                            <goal>install-node-and-yarn</goal>
                        </goals>
                        <configuration></configuration>
                    </execution>
                    <execution>
                        <phase>generate-resources</phase>
                        <id>yarn install</id>
                        <goals>
                            <goal>yarn</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
  </profile>
</profiles>
----

<1> Copies the files compiled by Polymer to a directory from where it can be served (root of the WAR)
<2> Copies the files compiled by Polymer to a directory where jetty:run can use as resource folder
<3> Configures the jetty plugin to use the extra resource folder
<4> Configures the frontend plugin to compile the web components source

=== Skipping compilation

To avoid recompiling the code every time you run a Maven command, you can use
the flag `-Dskip.bower`. For example, `mvn jetty:run -Dskip.bower` would run
Jetty without recompiling the components.

=== Directories created by the process

When resolving dependencies and compiling your components, several directories
and files are created inside your `src/main/frontend`. Those file can be
safely ignored in you SCM, since they are generated from the build.

Those files and directories are:

* bin/
* bower_components/
* build/
* etc/
* lib/
* node/
* node_modules/
* yarn.lock

== Manual compilation

If you don't want to use Maven to compile your components for you, you can use
the Polymer CLI directly (which uses polymer-build internally).

First step is to install the Polymer CLI tool. To do that, please
follow the steps mentioned at the https://www.polymer-project.org/2.0/docs/tools/polymer-cli[Polymer project]
page.

Using the same project structure and configuration files, you can run this
command from the `src/main/frontend` directory:

[source,bash]
----
polymer build
----

This will generate the `build` directory, which contains the compiled files.

== Linking both ES6 and ES5 files in your application

By using the `polymer.json` build configuration described above, two directories
are created: `build/es6` and `build/es5`. Those directories contain the ES6
optimized files and the ES5 optimized files respectively. You can serve both
build in your project, depending on the capabilities of the target browser.

To do that, in your component, you have to use the `frontend://` protocol when
declaring the path of your `HTMLImport`. For example:

[source,java]
----
@Tag("my-component")
@HtmlImport("frontend://components/my-component.html")
public class MyComponent extends PolymerTemplate<MyModel> {
----

In runtime, the Flow application will determine whether the browser supports ES6 or
not. When the browser supports ES6, the linked file will be served from
`(context)/VAADIN/static/frontend/es6/components/my-component.html`. When it
doesn`t, the served file will be
`(context)/VAADIN/static/frontend/es5/components/my-component.html`.

That way you can support ES5 browsers without compromising ES6 capable browsers.

=== Changing the target of `frontend://` served files

If you want to serve your files from other directory, or even from other servers
(like a CDN), you can change a couple of system properties without changing your
code. You just need to set:

* `frontend.url.es6` for the ES6 files URL
* `frontend.url.es5` for the ES5 files URL

When setting those properties from the command line, you have to use the `vaadin`
prefix. For example:

[source,bash]
----
mvn jetty:run -Dvaadin.frontend.url.es6=http://mydomain.com/es6/ -Dvaadin.frontend.url.es5=http://mydomain.com/es5/
----

You can also set those properties as Servlet init params. You can use the traditional `web.xml` file or the Servlet 3.0 `@WebServlet` annotation:

[source,java]
----
@WebServlet(urlPatterns = "/*", name = "myservlet", asyncSupported = true, initParams = {
        @WebInitParam(name = "frontend.url.es6", value = "http://mydomain.com/es6/"),
        @WebInitParam(name = "frontend.url.es5", value = "http://mydomain.com/es5/") })
@VaadinServletConfiguration(ui = MyUI.class, productionMode = false)
public class MyServlet extends VaadinServlet {
}
----

Or when using the `web.xml` file:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<web-app
  id="WebApp_ID" version="3.0"
  xmlns="http://java.sun.com/xml/ns/j2ee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd">

  <servlet>
    <servlet-name>myservlet</servlet-name>
    <servlet-class>
        com.vaadin.server.VaadinServlet
    </servlet-class>

    <init-param>
      <param-name>UI</param-name>
      <param-value>com.ex.myprj.MyUI</param-value>
    </init-param>

    <init-param>
      <param-name>frontend.url.es6</param-name>
      <param-value>http://mydomain.com/es6/</param-value>
    </init-param>

    <init-param>
      <param-name>frontend.url.es5</param-name>
      <param-value>http://mydomain.com/es5/</param-value>
    </init-param>
  </servlet>

  <servlet-mapping>
    <servlet-name>myservlet</servlet-name>
    <url-pattern>/*</url-pattern>
  </servlet-mapping>
</web-app>
----

When you set, for example, your `frontend.url.es6` property to
`http://mydomain.com/es6/`, the resulting URL for a component annotated with
`@HTMLImport("frontend://components/my-component.html")` will be
`http://mydomain.com/es6/components/my-component.html`.

[WARNING]
The base path defined by `frontend.url.es6` and `frontend.url.es5` properties
must end with a `/`.

[TIP]
You can also use the `context://` protocol in your `frontend.url.es6` and
`frontend.url.es5` properties. When doing so, the resulting URL will be relative
to the current context on the server.
