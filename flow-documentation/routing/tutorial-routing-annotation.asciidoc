---
title: Defining Routes With @Route
order: 1
layout: page
---

ifdef::env-github[:outfilesuffix: .asciidoc]
==== Work in progress

= Defining Routes With @Route
The `@Route` annotation allows you to define an arbitrary component as a route target for a given URL fragment. For example:

[source,java]
----
@Route("")
public class HelloWorld extends Div {
  public HelloWorld() {
    setText("Hello world");
  }
}
----
This defines the `HelloWorld` component as the default route target for the application (empty route). You can define a separate component for a different route like this:

[source,java]
----
@Route("some/path")
public class SomePathComponent extends Div {
  public SomePathComponent() {
    setText("Hello @Route!");
  }
}
----

So whenever the user navigates to `http://yourdomain.com/some/path` (assuming the app is running from the root context), either by clicking on links inside the application or by typing the address directly on the address bar, the `SomePathComponent` component would be shown at the page.

== ParentLayout route control using @RoutePrefix

In some cases there might be cases where a parent layout should supplement the navigation route
by adding to the route location.

This can be done by annotating a parent layout with `@RoutePrefix("prefix_to_add")`

[source, java]
----
@Route(value = "path", layout = SomeParent.class)
public class PathComponent extends Div {
    // Implementation omitted
}

@RoutePrefix("some")
public class SomeParent extends Div implements RouterLayout {
    // Implementation omitted
}
----

In this example the route that `PathComponent` would receive is `some/path` as in the case of the
previously mentioned `SomePathComponent`

=== Absolute routes

Sometimes we might have a setup where we want to use the same parent components in many parts,
but in some cases not use any `@ParentPrefix` from the parent chain or only use them for a defined part.

In these cases we can add `absolute = true` to either the `@Route` or `@ParentPrefix` annotations.

So if we have something that we want to use in many places in the `SomeParent` layout, but
do not want to get the route prefix added to our navigation path we could have a class `MyContent`
built the following way:

[source, java]
----
@Route(value = "content", layout = SomeParent.class, absolute = true)
public class MyContent extends Div {
    // Implementation omitted
}
----

In this case even though the full chain path should be `some/content` we actually get just `content`
as we have defined that this should be absolute.

The same works when having absolute defined in the middle of the chain for instance:

[source, java]
----
@RoutePrefix(value = "framework", absolute = true)
@ParentLayout(SomeParent.class)
public class FrameworkSite extends Div implements RouterLayout {
    // Implementation omitted
}

@Route(value = "tutorial", layout = FrameworkSite.class)
public class Tutorials extends Div {
    // Implementation omitted
}
----

In this case the bound route would be `framework/tutorial` even though the full chain
is `some/framework/tutorial`

[NOTE]
If a parent layout has a `@RoutePrefix` defined the "default" child could have its route
defined as `@Route("")` and be mapped to the parent layout route.
E.g. In the case of `Tutorials` with route "" it would be mapped as `framework/`
