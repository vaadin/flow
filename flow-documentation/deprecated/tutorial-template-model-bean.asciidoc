ifdef::env-github[:outfilesuffix: .asciidoc]
= Using Beans with a Template Model

For an introduction to templates and template models, see <<tutorial-template-basic#,Creating A Simple Component Using the AngularTemplate API>>

Using beans in models provides you with an easy way of defining your model or reusing existing beans for the model. You can use any bean together with the model as long as it has a public no-arg constructor.

A typical use case would be a form where you want to edit the contents of one or more entities. The template for a form for editing a `Person` bean might for instance look like:

[source,html]
----
<div>
  <div>
    <span>First name</span>
    <input [value]="person.firstName" />
  </div>
  <div>
    <span>Last name</span>
    <input [value]="person.lastName" />
  </div>
  <div>
    <span>Age</span>
    <input [value]="person.age" />
  </div>
</div>
----

Assuming your Person bean looks like:

[source,java]
----
public class Person {
    private String firstName, lastName;
    private int age;
    private Long id;

    public Person() {
        // Needed for TemplateModel
    }

    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }

    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }
}
----

You can specify your model to use a Person bean by adding a setter and a getter for it:

[source,java]
----
public interface FormModel extends TemplateModel {
  @Exclude("id")
  public void setPerson(Person person);
  public Person getPerson();
}
----

The method `setPerson` is annotated with the `@Exclude` annotation to avoid
importing the `id` property whose type is unsupported.
In the template you can initialize the model by setting a new person instance to it:

[source,java]
----
public class Form extends AngularTemplate {
    public Form() {
        Person person = new Person("John", "Doe", 82);
        getModel().setPerson(person);
    }

    @Override
    protected FormModel getModel() {
        return (FormModel) super.getModel();
    }
}
----
[TIP]
Alternatively you can use the `@Include` annotation and provide a list of properties that you want import.
All other properties will be excluded. In this specific case the
`@Include({"firstName","lastName","age"})` annotation does the same as the `@Exclude("id")` annotation. 

[NOTE]
If you later on update the `Person person` bean created in the constructor, nothing will happen to the model. The bean values are copied by `setPerson` and the bean is not attached to the model in any way.

To update the values in the model, you can use `getModel().getPerson()` to get a proxy `Person` object, which is attached to the model. Any changes you do to that proxy object will automatically update the model:

[source,java]
----
public class Form extends AngularTemplate {
    @ClientDelegate
    public void setNameToJeff() {
        getModel().getPerson().setFirstName("Jeff");
    }
}
----

[NOTE]
Your bean will never be stored as a bean in the model, instead the individual parts of the bean will be stored. No method will ever return the original bean to you.

[NOTE]
The proxy bean returned by the getter is not meant to be passed on to an `EntityManager` or similar. It is purely meant for updating the values in the model.

[WARNING]
There is at the time of writing no way to get a detached bean from the model.
