ifdef::env-github[:outfilesuffix: .asciidoc]
= Creating Template Contents Dynamically Based on a List of Items

The AngularTemplate API provides you a way to generate elements based on a list of items
by iterating them using a `*ngFor` for-loop.

[source,html]
----
<table>
  <tr>
    <th>Name</th><th>Title</th><th>Email</th>
  </tr>
  <tr *ngFor="let employee of employees">
    <td>{{employee.name}}</td>
    <td>{{employee.title}}</td>
    <td>{{employee.email}}</td>
  </tr>
</table>
----

The above template might look like this once populated with a list of employees:

[cols=">s,^m,e",options="header"]
|==========================
|Name   |Title     |Email
|John D |Developer | jd@foo.bar
|Jane D |Designer  | janed@foo.bar
|Mike D |Architect | mikey@foo.bar
|==========================

The `*ngFor` attribute marks the element that is generated for each item in a list.
In the above example the table's rows and everything inside the row element `<tr>...</tr>` is created for each item in the list.

The value of the `*ngFor` attribute declares the items to loop and the name of the loop variable:

* `let` precedes the name of the loop variable, e.g. _employee_.
This variable is available for <<../tutorial-template-bindings#,data binding>> inside
the element tags.
* `of` precedes the name of the list inside the template model to iterate, e.g. _employees_.

[NOTE]
You currently can't nest multiple `*ngFor` for-loops.

== Populating the List of Items

You should declare a method in the template's model interface for setting the list of beans that should be shown.
The name of the method should match the name in the `*ngFor` definition; data for `... of employees` is set by a method named `setEmployees`.

[source,java]
----
public class EmployeesTable extends AngularTemplate {
  public interface EmployeesModel extends TemplateModel {
      @Include({ "name", "title", "email" })
      void setEmployees(List<Employee> employees);

      List<Employee> getEmployees();
  }

  @Override
  protected EmployeesModel getModel() {
      return (EmployeesModel) super.getModel();
  }

  public void setEmployees(List<Employee> employees) {
      getModel().setEmployees(employees);
  }
  
  public List<Employee> getEmployees() {
      return getModel().getEmployees();
  }
}
----

The `@Include` annotation is used here to limit which properties to import into the model.
This is done to exclude the `id` property whose type is unsupported. Alternatively you can use a `@Exclude("id")` in this specific case.

The `Employee` bean should have getters corresponding the properties used inside the `*ngFor` definition in the template, e.g. `getName()` for `employee.name`.

[source,java]
----
public class Employee {
    private String name;
    private String title;
    private String email;
    private long id;

    public Employee(String name, String title, String email, long id) {
        this.name = name;
        this.title = title;
        this.email = email;
    }

    public String getName() {
        return name;
    }

    public String getTitle() {
        return title;
    }

    public String getEmail() {
        return email;
    }
    
    public void setName(String name) {
        this.name = name;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setEmail(String email) {
        this.email = email;
    }
    
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }
}
----

[NOTE]
Setters are not required here. The template engine will use only the getter to fetch values from employee beans. 

== Updating the Items

The beans that you add to the model using the `setEmployees()` method are used to populate the model only.
It means that any update made to the bean will not update the model. 
To be able to update the model items you should use `getEmployees()` which returns bean proxies which are connected to the model.
Any change made to the proxy instance will be reflected to the model.

Here is the way to update the title for all items:

[source,java]
----
public void updateTitle() {
    getEmployees().stream().forEach(employee -> employee.setTitle("Mr."));
}
----

[NOTE]
You can also use `setEmployees()` method with a new list of updated beans to repopulate the model. This is not very convenient if you want to update only a single item or a single property.
