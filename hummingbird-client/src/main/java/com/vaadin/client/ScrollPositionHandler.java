/*
 * Copyright 2000-2016 Vaadin Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.vaadin.client;

import com.google.web.bindery.event.shared.HandlerRegistration;
import com.vaadin.client.hummingbird.collection.JsArray;
import com.vaadin.client.hummingbird.collection.JsCollections;

import elemental.client.Browser;
import elemental.events.PopStateEvent;
import elemental.json.Json;
import elemental.json.JsonObject;

/**
 * Handler for restoring scroll position when user navigates back / forward
 * inside the application. This is used instead of browser's native
 * <code>history.scrollRestoration = "auto"</code> since it won't work with
 * content generated by JavaScript.
 * <p>
 * Currently only handles the scroll position of <code>body.scrollTop</code>.
 * <p>
 * Currently missing the feature of keeping restoring the scroll positions when
 * the user navigates back from another site.
 *
 * @author Vaadin Ltd
 */
public class ScrollPositionHandler {

    /**
     * Key used to store scroll position into History.state.
     */
    private static final String HISTORY_POSITION = "historyPosition";

    private final Registry registry;

    private final JsArray<Integer> scrollPositions = JsCollections.array();

    private HandlerRegistration responseHandlingEndedHandler;

    private int currentHistoryPosition;

    private boolean ignoreNextPopStateEvent;

    /**
     * Creates a new instance connected to the given registry.
     *
     * @param registry
     *            the global registry
     */
    public ScrollPositionHandler(Registry registry) {
        this.registry = registry;

        // use custom scroll restoration instead of browser implementation
        disableNativeScrollRestoration();
    }

    /**
     * Store scroll positions and restore scroll positions depending on the
     * given pop state event.
     * <p>
     * This method behaves differently if there has been a
     * {@link #onLinkClick(String, boolean)} before this, and if the pop state
     * event is inside page navigation (fragment change).
     *
     * @param event
     *            the pop state event
     * @param isInsidePageNavigation
     *            <code>true</code> if the pop state event is related to inside
     *            page navigation, <code>false</code> if not
     */
    public void onPopStateEvent(PopStateEvent event,
            boolean isInsidePageNavigation) {
        if (ignoreNextPopStateEvent) {
            Browser.getWindow().getHistory().replaceState(
                    createHistoryPositionState(), "",
                    Browser.getDocument().getLocation().getHref());

            ignoreNextPopStateEvent = false;
        } else if (scrollPositions.isEmpty()) {
            // just ignore (for now) if user has navigated back from another
            // site
        } else {
            storeCurrentScrollPosition();
            restoreScrollPosition(event, !isInsidePageNavigation);
        }
    }

    /**
     * Store scroll positions when there has been a click on a link element.
     * <p>
     * Inside page navigation link clicks (e.g. fragment changes) are a special
     * case since they cause a pop state event.
     *
     * @param newHref
     *            the href of the clicked link
     * @param isInsidePageNavigation
     *            <code>true</code> if the pop state event is related to inside
     *            page navigation, <code>false</code> if not
     */
    public void onLinkClick(String newHref, boolean isInsidePageNavigation) {
        storeCurrentScrollPosition();

        Browser.getWindow().getHistory().replaceState(
                createHistoryPositionState(), "",
                Browser.getWindow().getLocation().getHref());

        // move to page top only if there is no fragment so scroll position
        // doesn't bounce around
        if (!newHref.contains("#")) {
            Browser.getWindow().scrollTo(0, 0);
        }

        currentHistoryPosition++;

        // there will be a pop state event fired for inside page navigation
        ignoreNextPopStateEvent = isInsidePageNavigation;
        if (!isInsidePageNavigation) {
            // store new position
            Browser.getWindow().getHistory()
                    .pushState(createHistoryPositionState(), "", newHref);
        }
        // remove old stored scroll positions
        scrollPositions.splice(currentHistoryPosition,
                scrollPositions.length() - currentHistoryPosition);
    }

    private void storeCurrentScrollPosition() {
        int bodyScrollTop = Browser.getWindow().getScrollY();
        scrollPositions.set(currentHistoryPosition, bodyScrollTop);
    }

    private JsonObject createHistoryPositionState() {
        JsonObject state = Json.createObject();
        state.put(HISTORY_POSITION, currentHistoryPosition);
        return state;
    }

    private void restoreScrollPosition(PopStateEvent event,
            boolean delayAfterResponse) {
        JsonObject state = (JsonObject) event.getState();

        // in case there is another event while waiting for response (?)
        if (responseHandlingEndedHandler != null) {
            responseHandlingEndedHandler.removeHandler();
        }

        if (state != null && state.hasKey(HISTORY_POSITION)) {
            currentHistoryPosition = (int) state.getNumber(HISTORY_POSITION);
            assert currentHistoryPosition < scrollPositions
                    .length() : "No matching scroll location (size:"
                            + scrollPositions.length()
                            + ") for opened history position ("
                            + currentHistoryPosition + ")";

            int bodyScrollTop = scrollPositions.get(currentHistoryPosition);

            if (delayAfterResponse) {
                responseHandlingEndedHandler = registry
                        .getRequestResponseTracker()
                        .addResponseHandlingEndedHandler(
                                responseHandlingEndedEvent -> {
                                    Browser.getWindow().scrollTo(0,
                                            bodyScrollTop);
                                    responseHandlingEndedHandler
                                            .removeHandler();
                                });
            } else {
                Browser.getWindow().scrollTo(0, bodyScrollTop);
            }
        }
    }

    private static native void disableNativeScrollRestoration()
    /*-{
       if ('scrollRestoration' in history) {
           history.scrollRestoration = "manual";
       }
    }-*/;
}
