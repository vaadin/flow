/*
 * Copyright 2000-2016 Vaadin Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.vaadin.client;

import com.google.web.bindery.event.shared.HandlerRegistration;
import com.vaadin.client.hummingbird.collection.JsArray;
import com.vaadin.client.hummingbird.collection.JsCollections;

import elemental.client.Browser;
import elemental.events.Event;
import elemental.events.PopStateEvent;
import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonObject;

/**
 * Handler for restoring scroll position when user navigates back / forward
 * inside the application. This is used instead of browser's native
 * <code>history.scrollRestoration = "auto"</code> since it won't work with
 * content generated by JavaScript.
 *
 * @author Vaadin Ltd
 */
public class ScrollPositionHandler {

    /**
     * Key used to store scroll position into History.state.
     */
    private static final String HISTORY_POSITION = "historyPosition";

    /**
     * Key used to store X positions into History.state.
     */
    private static final String X_POSITIONS = "xPositions";

    /**
     * Key used to store Y positions into History.state.
     */
    private static final String Y_POSITIONS = "yPositions";

    private final Registry registry;

    private final JsArray<Integer> yPositions;
    private final JsArray<Integer> xPositions;

    private HandlerRegistration responseHandlingEndedHandler;

    private int currentHistoryPosition;

    private boolean ignoreNextPopStateEvent;

    /**
     * Creates a new instance connected to the given registry.
     *
     * @param registry
     *            the global registry
     */
    public ScrollPositionHandler(Registry registry) {
        this.registry = registry;

        // use custom scroll restoration instead of browser implementation
        disableNativeScrollRestoration();

        // before leaving the app need to store scroll positions to state
        Browser.getWindow().addEventListener("beforeunload",
                this::onBeforeUnload);

        // restore scroll positions from state if applicable
        JsonObject state = (JsonObject) Browser.getWindow().getHistory()
                .getState();
        if (state != null && state.hasKey(HISTORY_POSITION)) {
            currentHistoryPosition = (int) state.getNumber(HISTORY_POSITION);

            assert state.hasKey(
                    X_POSITIONS) : "X Scroll Positions not stored in History.state";
            assert state.hasKey(
                    Y_POSITIONS) : "Y Scroll Positions not stored in History.state";

            xPositions = convertJsonArray(state.getArray(X_POSITIONS));
            yPositions = convertJsonArray(state.getArray(Y_POSITIONS));

            // setting scroll after response handling will make it jump a
            // bit, but transitioning from prerendering to live app might
            // change the page size
            restoreScrollPosition(state, true);

        } else {
            xPositions = JsCollections.array();
            yPositions = JsCollections.array();
        }
    }

    private void onBeforeUnload(Event event) {
        storeCurrentScrollPosition();

        JsonObject stateObject = createStateObjectWithHistoryPosition();
        stateObject.put(X_POSITIONS, convertArrayToJsonArray(xPositions));
        stateObject.put(Y_POSITIONS, convertArrayToJsonArray(yPositions));

        Browser.getWindow().getHistory().replaceState(stateObject, "",
                Browser.getWindow().getLocation().getHref());
    }

    /**
     * Store scroll positions and restore scroll positions depending on the
     * given pop state event.
     * <p>
     * This method behaves differently if there has been a
     * {@link #onLinkClick(String, boolean)} before this, and if the pop state
     * event is inside page navigation (fragment change).
     *
     * @param event
     *            the pop state event
     * @param isInsidePageNavigation
     *            <code>true</code> if the pop state event is related to inside
     *            page navigation, <code>false</code> if not
     */
    public void onPopStateEvent(PopStateEvent event,
            boolean isInsidePageNavigation) {
        if (ignoreNextPopStateEvent) {
            Browser.getWindow().getHistory().replaceState(
                    createStateObjectWithHistoryPosition(), "",
                    Browser.getDocument().getLocation().getHref());

            ignoreNextPopStateEvent = false;
        } else {
            storeCurrentScrollPosition();
            restoreScrollPosition((JsonObject) event.getState(),
                    !isInsidePageNavigation);
        }
    }

    /**
     * Store scroll positions when there has been a click on a link element.
     * <p>
     * Inside page navigation link clicks (e.g. fragment changes) are a special
     * case since they cause a pop state event.
     *
     * @param newHref
     *            the href of the clicked link
     * @param isInsidePageNavigation
     *            <code>true</code> if the pop state event is related to inside
     *            page navigation, <code>false</code> if not
     */
    public void onLinkClick(String newHref, boolean isInsidePageNavigation) {
        storeCurrentScrollPosition();

        Browser.getWindow().getHistory().replaceState(
                createStateObjectWithHistoryPosition(), "",
                Browser.getWindow().getLocation().getHref());

        // move to page top only if there is no fragment so scroll position
        // doesn't bounce around
        if (!newHref.contains("#")) {
            Browser.getWindow().scrollTo(0, 0);
        } else if (newHref.contains("#") && !isInsidePageNavigation) {
            // need to set scrollX to 0 since browser fragment handling will
            // only effect scrollY
            Browser.getWindow().scrollTo(0, Browser.getWindow().getScrollY());
        }

        currentHistoryPosition++;

        // there will be a pop state event fired for inside page navigation
        ignoreNextPopStateEvent = isInsidePageNavigation;
        if (!isInsidePageNavigation) {
            // store new position
            Browser.getWindow().getHistory().pushState(
                    createStateObjectWithHistoryPosition(), "", newHref);
        }
        // remove old stored scroll positions
        yPositions.splice(currentHistoryPosition,
                yPositions.length() - currentHistoryPosition);
        xPositions.splice(currentHistoryPosition, xPositions.length());
    }

    private void storeCurrentScrollPosition() {
        int scrollY = Browser.getWindow().getScrollY();
        yPositions.set(currentHistoryPosition, scrollY);

        int scrollX = Browser.getWindow().getScrollX();
        xPositions.set(currentHistoryPosition, scrollX);
    }

    private JsonObject createStateObjectWithHistoryPosition() {
        JsonObject state = Json.createObject();
        state.put(HISTORY_POSITION, currentHistoryPosition);
        return state;
    }

    private void restoreScrollPosition(JsonObject state,
            boolean delayAfterResponse) {
        // in case there is another event while waiting for response (?)
        if (responseHandlingEndedHandler != null) {
            responseHandlingEndedHandler.removeHandler();
        }

        if (state != null && state.hasKey(HISTORY_POSITION)) {
            currentHistoryPosition = (int) state.getNumber(HISTORY_POSITION);
            assert currentHistoryPosition < yPositions
                    .length() : "No matching Y scroll position (size:"
                            + yPositions.length()
                            + ") for opened history position ("
                            + currentHistoryPosition + ")";
            assert currentHistoryPosition < xPositions
                    .length() : "No matching scroll position (size:"
                            + xPositions.length()
                            + ") for opened history position ("
                            + currentHistoryPosition + ")";
            int scrollY = yPositions.get(currentHistoryPosition);
            int scrollX = xPositions.get(currentHistoryPosition);

            if (delayAfterResponse) {
                responseHandlingEndedHandler = registry
                        .getRequestResponseTracker()
                        .addResponseHandlingEndedHandler(
                                responseHandlingEndedEvent -> {
                                    Browser.getWindow().scrollTo(scrollX,
                                            scrollY);
                                    responseHandlingEndedHandler
                                            .removeHandler();
                                });
            } else {
                Browser.getWindow().scrollTo(scrollX, scrollY);
            }
        }
    }

    private static JsArray<Integer> convertJsonArray(JsonArray jsonArray) {
        JsArray<Integer> array = JsCollections.array();
        for (int i = 0; i < jsonArray.length(); i++) {
            array.push((int) jsonArray.getNumber(i));
        }
        return array;
    }

    private static JsonArray convertArrayToJsonArray(JsArray<Integer> array) {
        JsonArray jsonArray = Json.createArray();
        for (int i = 0; i < array.length(); i++) {
            jsonArray.set(i, array.get(i));
        }
        return jsonArray;
    }

    private static native void disableNativeScrollRestoration()
    /*-{
       if ('scrollRestoration' in history) {
           history.scrollRestoration = "manual";
       }
    }-*/;
}
