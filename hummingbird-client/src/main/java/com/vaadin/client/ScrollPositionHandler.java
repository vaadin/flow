/*
 * Copyright 2000-2016 Vaadin Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.vaadin.client;

import com.google.web.bindery.event.shared.HandlerRegistration;
import com.vaadin.client.hummingbird.collection.JsArray;
import com.vaadin.client.hummingbird.collection.JsCollections;

import elemental.client.Browser;
import elemental.events.Event;
import elemental.events.PopStateEvent;
import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonObject;

/**
 * Handler for restoring scroll position when user navigates back / forward
 * inside the application. This is used instead of browser's native
 * <code>history.scrollRestoration = "auto"</code> since it won't work with
 * content generated by JavaScript.
 *
 * @author Vaadin Ltd
 */
public class ScrollPositionHandler {

    private static final String CONSOLE_ERROR_EXPLANATION = "Unable to restore scroll positions. History.state has been manipulated or user has navigated away from site in an unrecognized way.";

    /**
     * Key used to store scroll position into History.state.
     */
    private static final String HISTORY_POSITION = "historyPosition";

    /**
     * Key used to store X positions into History.state.
     */
    private static final String X_POSITIONS = "xPositions";

    /**
     * Key used to store Y positions into History.state.
     */
    private static final String Y_POSITIONS = "yPositions";

    private final Registry registry;

    private JsArray<Double> yPositions;
    private JsArray<Double> xPositions;

    private HandlerRegistration responseHandlingEndedHandler;

    private int currentHistoryPosition;

    private boolean navigatedInsidePage;

    /**
     * Creates a new instance connected to the given registry.
     *
     * @param registry
     *            the global registry
     */
    public ScrollPositionHandler(Registry registry) {
        this.registry = registry;

        // use custom scroll restoration instead of browser implementation
        disableNativeScrollRestoration();

        // before leaving the app need to store scroll positions to state
        Browser.getWindow().addEventListener("beforeunload",
                this::onBeforeUnload);

        // restore scroll positions from state if applicable
        JsonObject state = (JsonObject) Browser.getWindow().getHistory()
                .getState();
        if (state != null && state.hasKey(HISTORY_POSITION)) {
            if (!state.hasKey(X_POSITIONS) || !state.hasKey(Y_POSITIONS)) {
                Console.warn(
                        "No X/Y scroll position available in History.state. "
                                + CONSOLE_ERROR_EXPLANATION);
                resetScrollPositionTracking();
                return;
            }

            currentHistoryPosition = (int) state.getNumber(HISTORY_POSITION);
            xPositions = convertJsonArrayToArray(state.getArray(X_POSITIONS));
            yPositions = convertJsonArrayToArray(state.getArray(Y_POSITIONS));

            // array lengths checked in restoreScrollPosition
            restoreScrollPosition(state, true);
        } else {
            resetScrollPositionTracking();
        }
    }

    private void onBeforeUnload(Event event) {
        storeCurrentScrollPosition();

        JsonObject stateObject = createStateObjectWithHistoryPosition();
        stateObject.put(X_POSITIONS, convertArrayToJsonArray(xPositions));
        stateObject.put(Y_POSITIONS, convertArrayToJsonArray(yPositions));

        Browser.getWindow().getHistory().replaceState(stateObject, "",
                Browser.getWindow().getLocation().getHref());
    }

    /**
     * Store scroll positions and restore scroll positions depending on the
     * given pop state event.
     * <p>
     * This method behaves differently if there has been a
     * {@link #beforeNavigation(String, boolean)} before this, and if the pop
     * state event is caused by a fragment change that doesn't require a server
     * side round-trip.
     *
     * @param event
     *            the pop state event
     * @param triggersServerSideRoundtrip
     *            <code>true</code> if the pop state event triggers a server
     *            side request, <code>false</code> if not
     */
    public void onPopStateEvent(PopStateEvent event,
            boolean triggersServerSideRoundtrip) {
        if (navigatedInsidePage) {
            Browser.getWindow().getHistory().replaceState(
                    createStateObjectWithHistoryPosition(), "",
                    Browser.getDocument().getLocation().getHref());

            navigatedInsidePage = false;
        } else {
            // capture the "old" page scroll positions to arrays
            storeCurrentScrollPosition();

            restoreScrollPosition((JsonObject) event.getState(),
                    !triggersServerSideRoundtrip);
        }
    }

    /**
     * Store scroll positions when there has been a click on a link element.
     * <p>
     * Inside page navigation link clicks (e.g. fragment changes) are a special
     * case since they cause a pop state event.
     *
     * @param newHref
     *            the href of the clicked link
     * @param isInsidePageNavigation
     *            <code>true</code> if the pop state event is related to inside
     *            page navigation, <code>false</code> if not
     */
    public void beforeNavigation(String newHref,
            boolean isInsidePageNavigation) {
        storeCurrentScrollPosition();

        Browser.getWindow().getHistory().replaceState(
                createStateObjectWithHistoryPosition(), "",
                Browser.getWindow().getLocation().getHref());

        // move to page top only if there is no fragment so scroll position
        // doesn't bounce around
        if (!newHref.contains("#")) {
            Browser.getWindow().scrollTo(0, 0);
        }

        currentHistoryPosition++;

        // there will be a pop state event fired for inside page navigation
        navigatedInsidePage = isInsidePageNavigation;
        if (!isInsidePageNavigation) {
            // store new position
            Browser.getWindow().getHistory().pushState(
                    createStateObjectWithHistoryPosition(), "", newHref);
        }
        // remove old stored scroll positions
        yPositions.splice(currentHistoryPosition,
                yPositions.length() - currentHistoryPosition);
        xPositions.splice(currentHistoryPosition,
                xPositions.length() - currentHistoryPosition);
    }

    private void storeCurrentScrollPosition() {
        yPositions.set(currentHistoryPosition,
                Double.valueOf(Browser.getWindow().getScrollY()));
        xPositions.set(currentHistoryPosition,
                Double.valueOf(Browser.getWindow().getScrollX()));
    }

    private JsonObject createStateObjectWithHistoryPosition() {
        JsonObject state = Json.createObject();
        state.put(HISTORY_POSITION, currentHistoryPosition);
        return state;
    }

    private void restoreScrollPosition(JsonObject state,
            boolean delayAfterResponse) {
        // in case there is another event while waiting for response (?)
        if (responseHandlingEndedHandler != null) {
            responseHandlingEndedHandler.removeHandler();
        }

        if (state != null && state.hasKey(HISTORY_POSITION)) {
            currentHistoryPosition = (int) state.getNumber(HISTORY_POSITION);
            if (yPositions.length() < currentHistoryPosition
                    || xPositions.length() < currentHistoryPosition) {
                Console.warn("No matching scroll position found (entries Y:"
                        + yPositions.length() + ", X:" + xPositions.length()
                        + ") for opened history position ("
                        + currentHistoryPosition + "). "
                        + CONSOLE_ERROR_EXPLANATION);
                resetScrollPositionTracking();
                return;
            }
            int scrollY = yPositions.get(currentHistoryPosition).intValue();
            int scrollX = xPositions.get(currentHistoryPosition).intValue();

            if (delayAfterResponse) {
                responseHandlingEndedHandler = registry
                        .getRequestResponseTracker()
                        .addResponseHandlingEndedHandler(
                                responseHandlingEndedEvent -> {
                                    Browser.getWindow().scrollTo(scrollX,
                                            scrollY);
                                    responseHandlingEndedHandler
                                            .removeHandler();
                                });
            } else {
                Browser.getWindow().scrollTo(scrollX, scrollY);
            }
        } else {
            Console.warn(CONSOLE_ERROR_EXPLANATION);
        }
    }

    private void resetScrollPositionTracking() {
        xPositions = JsCollections.array();
        yPositions = JsCollections.array();
        currentHistoryPosition = 0;
    }

    private static JsArray<Double> convertJsonArrayToArray(
            JsonArray jsonArray) {
        return WidgetUtil.crazyJsCast(jsonArray);
    }

    private static JsonArray convertArrayToJsonArray(JsArray<Double> array) {
        return WidgetUtil.crazyJsCast(array);
    }

    private static native void disableNativeScrollRestoration()
    /*-{
       if ('scrollRestoration' in history) {
           history.scrollRestoration = "manual";
       }
    }-*/;
}
