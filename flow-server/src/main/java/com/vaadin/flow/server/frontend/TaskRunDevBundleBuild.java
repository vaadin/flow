/*
 * Copyright 2000-2023 Vaadin Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.vaadin.flow.server.frontend;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.vaadin.flow.internal.JsonUtils;
import com.vaadin.flow.internal.UsageStatistics;
import com.vaadin.flow.server.Constants;
import com.vaadin.flow.server.ExecutionFailedException;
import com.vaadin.flow.server.frontend.scanner.ClassFinder;
import com.vaadin.flow.server.frontend.scanner.FrontendDependenciesScanner;
import com.vaadin.flow.shared.util.SharedUtil;

import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonObject;
import elemental.json.JsonType;
import elemental.json.JsonValue;

import static com.vaadin.flow.server.Constants.DEV_BUNDLE_JAR_PATH;

/**
 * Compiles the dev mode bundle if it is out of date.
 * <p>
 * Only used when running in dev mode without a dev server.
 * <p>
 * For internal use only. May be renamed or removed in a future release.
 */
public class TaskRunDevBundleBuild implements FallibleCommand {

    private static final Pattern THEME_PATH_PATTERN = Pattern
            .compile("themes\\/([\\s\\S]+?)\\/theme.json");

    //@formatter:off
    public static final String README =
            "This directory is automatically generated by Vaadin and contains the pre-compiled \n" +
            "frontend files/resources for your project (frontend development bundle).\n\n" +
            "It should be added to Version Control System and committed, so that other developers\n" +
            "do not have to compile it again.\n\n" +
            "Frontend development bundle is automatically updated when needed:\n" +
            "- an npm/pnpm package is added with @NpmPackage or directly into package.json\n" +
            "- CSS, JavaScript or TypeScript files are added with @CssImport, @JsModule or @JavaScript\n" +
            "- Vaadin add-on with front-end customizations is added\n" +
            "- Custom theme imports/assets added into 'theme.json' file\n" +
            "- Exported web component is added.\n\n" +
            "If your project development needs a hot deployment of the frontend changes, \n" +
            "you can switch Flow to use Vite development server (default in Vaadin 23.3 and earlier versions):\n" +
            "- set `vaadin.frontend.hotdeploy=true` in `application.properties`\n" +
            "- configure `vaadin-maven-plugin`:\n" +
            "```\n" +
            "   <configuration>\n" +
            "       <frontendHotdeploy>true</frontendHotdeploy>\n" +
            "   </configuration>\n" +
            "```\n" +
            "- configure `jetty-maven-plugin`:\n" +
            "```\n" +
            "   <configuration>\n" +
            "       <systemProperties>\n" +
            "           <vaadin.frontend.hotdeploy>true</vaadin.frontend.hotdeploy>\n" +
            "       </systemProperties>\n" +
            "   </configuration>\n" +
            "```\n\n" +
            "Read more [about Vaadin development mode](https://vaadin.com/docs/next/configuration/development-mode/#pre-compiled-front-end-bundle-for-faster-start-up).";
    //@formatter:on

    public static final String README_NOT_CREATED = "Failed to create a README file in "
            + Constants.DEV_BUNDLE_LOCATION;

    private final Options options;

    /**
     * Create an instance of the command.
     *
     * @param options
     *            the task options
     */
    TaskRunDevBundleBuild(Options options) {
        this.options = options;
    }

    @Override
    public void execute() throws ExecutionFailedException {
        getLogger().info(
                "Creating a new development mode bundle. This can take a while but will only run when the project setup is changed, addons are added or frontend files are modified");

        runFrontendBuildTool("Vite", "vite/bin/vite.js", Collections.emptyMap(),
                "build");

        addReadme();
    }

    public static boolean needsBuild(Options options,
            FrontendDependenciesScanner frontendDependencies,
            ClassFinder finder) {
        getLogger()
                .info("Checking if a development mode bundle build is needed");

        try {
            boolean needsBuild = needsBuildInternal(options,
                    frontendDependencies, finder);
            if (needsBuild) {
                getLogger().info("A development mode bundle build is needed");
            } else {
                getLogger()
                        .info("A development mode bundle build is not needed");
            }
            return needsBuild;
        } catch (Exception e) {
            getLogger().error(
                    "Error when checking if a development bundle build is needed",
                    e);
            return true;
        }
    }

    protected static boolean needsBuildInternal(Options options,
            FrontendDependenciesScanner frontendDependencies,
            ClassFinder finder) throws IOException {
        File npmFolder = options.getNpmFolder();

        if (!DevBundleUtils.getDevBundleFolder(npmFolder).exists()
                && !BundleValidationUtil.hasJarBundle(DEV_BUNDLE_JAR_PATH)) {
            getLogger().info("No dev-bundle found.");
            return true;
        }

        if (options.isSkipDevBundle()) {
            // if skip dev bundle defined and we have a dev bundle,
            // cancel all checks and trust existing bundle
            getLogger()
                    .info("Skip dev bundle requested. Using existing bundle.");
            return false;
        }

        String statsJsonContent = DevBundleUtils.findBundleStatsJson(npmFolder);
        if (statsJsonContent == null) {
            // without stats.json in bundle we can not say if it is up-to-date
            getLogger().info("No dev-bundle stats.json found for validation.");
            return true;
        }

        JsonObject packageJson = BundleValidationUtil.getPackageJson(options,
                frontendDependencies, finder);
        JsonObject statsJson = Json.parse(statsJsonContent);

        // Get scanned @NpmPackage annotations
        final Map<String, String> npmPackages = frontendDependencies
                .getPackages();

        if (!BundleValidationUtil.hashAndBundleModulesEqual(statsJson,
                packageJson, npmPackages)) {
            UsageStatistics.markAsUsed("flow/rebundle-reason-missing-package",
                    null);
            // Hash in the project doesn't match the bundle hash or NpmPackages
            // are found missing in bundle.
            return true;
        }
        if (!BundleValidationUtil.frontendImportsFound(statsJson, options,
                finder, frontendDependencies)) {
            UsageStatistics.markAsUsed(
                    "flow/rebundle-reason-missing-frontend-import", null);
            return true;
        }

        if (themeConfigurationChanged(options, statsJson,
                frontendDependencies)) {
            UsageStatistics.markAsUsed(
                    "flow/rebundle-reason-changed-theme-config", null);
            return true;
        }

        if (BundleValidationUtil.exportedWebComponents(statsJson, finder)) {
            UsageStatistics.markAsUsed(
                    "flow/rebundle-reason-added-exported-component", null);
            return true;
        }

        return false;
    }

    private static boolean themeConfigurationChanged(Options options,
            JsonObject statsJson,
            FrontendDependenciesScanner frontendDependencies) {
        Map<String, JsonObject> themeJsonContents = new HashMap<>();

        if (options.getJarFiles() != null) {
            options.getJarFiles().stream().filter(File::exists)
                    .filter(file -> !file.isDirectory())
                    .forEach(jarFile -> getPackagedThemeJsonContents(jarFile,
                            themeJsonContents));
        }

        Optional<String> maybeThemeName = Optional
                .ofNullable(frontendDependencies.getThemeDefinition())
                .map(def -> def.getName()).filter(name -> !name.isBlank());
        Optional<JsonObject> projectThemeJson = maybeThemeName
                .flatMap(themeName -> ThemeUtils.getThemeJson(
                        options.getFrontendDirectory(), themeName));
        String projectThemeName = maybeThemeName.orElse(null);

        JsonObject statsThemeJson = statsJson.getObject("themeJsonContents");
        if (statsThemeJson == null && (!themeJsonContents.isEmpty()
                || projectThemeJson.isPresent())) {
            getLogger().info(
                    "Found newly added theme configurations in 'theme.json'.");
            return true;
        }

        if (projectThemeJson.isPresent()) {
            String key;
            if (statsThemeJson.hasKey(projectThemeName)) {
                key = projectThemeName;
            } else if (statsThemeJson.hasKey(Constants.DEV_BUNDLE_NAME)) {
                key = Constants.DEV_BUNDLE_NAME;
            } else {
                getLogger().info(
                        "Found newly added configuration for project theme '{}' in 'theme.json'.",
                        projectThemeName);
                return true;
            }

            collectThemeJsonContentsInFrontend(options, themeJsonContents, key,
                    projectThemeJson.get());
        }

        for (Map.Entry<String, JsonObject> themeContent : themeJsonContents
                .entrySet()) {
            if (hasNewAssetsOrImports(statsThemeJson, themeContent)) {
                getLogger().info(
                        "Found new configuration for theme '{}' in 'theme.json'.",
                        themeContent.getKey());
                return true;
            } else if (statsThemeJson.hasKey(themeContent.getKey())) {
                List<String> missedKeys = new ArrayList<>();
                JsonObject content = Json
                        .parse(statsThemeJson.getString(themeContent.getKey()));
                if (!objectIncludesEntry(content, themeContent.getValue(),
                        missedKeys)) {
                    getLogger().info(
                            "Custom theme '{}' has imports/assets in 'theme.json' not present in the bundle",
                            themeContent.getKey());
                    logMissedEntries(missedKeys);
                    return true;
                }
            }
        }

        return false;
    }

    private static boolean hasNewAssetsOrImports(JsonObject contentsInStats,
            Map.Entry<String, JsonObject> themeContent) {
        JsonObject json = themeContent.getValue();
        boolean moreThanOneKey = json.keys().length > 1;
        boolean noParentEntry = json.keys().length == 1
                && !json.hasKey("parent");
        // do not re-bundle immediately if theme.json is empty or has only
        // parent reference
        return !contentsInStats.hasKey(themeContent.getKey())
                && (moreThanOneKey || noParentEntry);
    }

    private static void collectThemeJsonContentsInFrontend(Options options,
            Map<String, JsonObject> themeJsonContents, String themeName,
            JsonObject themeJson) {
        Optional<String> parentThemeInFrontend = ThemeUtils
                .getParentThemeName(themeJson);
        if (parentThemeInFrontend.isPresent()) {
            String parentThemeName = parentThemeInFrontend.get();
            Optional<JsonObject> parentThemeJson = ThemeUtils.getThemeJson(
                    options.getFrontendDirectory(), parentThemeName);
            if (parentThemeJson.isPresent()) {
                collectThemeJsonContentsInFrontend(options, themeJsonContents,
                        parentThemeName, parentThemeJson.get());
            }
        }

        themeJsonContents.put(themeName, themeJson);
    }

    private static boolean objectIncludesEntry(JsonValue jsonFromBundle,
            JsonValue projectJson, Collection<String> missedKeys) {
        JsonType bundleJsonType = jsonFromBundle.getType();
        JsonType projectJsonObjectTypeType = projectJson.getType();
        assert bundleJsonType.equals(projectJsonObjectTypeType);

        if (bundleJsonType == JsonType.NULL) {
            return true;
        } else if (bundleJsonType == JsonType.BOOLEAN) {
            return JsonUtils.booleanEqual(jsonFromBundle, projectJson);
        } else if (bundleJsonType == JsonType.NUMBER) {
            return JsonUtils.numbersEqual(jsonFromBundle, projectJson);
        } else if (bundleJsonType == JsonType.STRING) {
            return JsonUtils.stringEqual(jsonFromBundle, projectJson);
        } else if (bundleJsonType == JsonType.ARRAY) {
            JsonArray jsonArrayFromBundle = (JsonArray) jsonFromBundle;
            JsonArray projectJsonArray = (JsonArray) projectJson;
            return compareArrays(missedKeys, jsonArrayFromBundle,
                    projectJsonArray);
        } else if (bundleJsonType == JsonType.OBJECT) {
            JsonObject jsonObjectFromBundle = (JsonObject) jsonFromBundle;
            JsonObject projectJsonObject = (JsonObject) projectJson;
            return compareObjects(missedKeys, jsonObjectFromBundle,
                    projectJsonObject);
        } else {
            throw new IllegalArgumentException(
                    "Unsupported JsonType: " + bundleJsonType);
        }
    }

    private static void logMissedEntries(List<String> missedKeys) {
        Collections.reverse(missedKeys);
        BundleValidationUtil.logChangedFiles(missedKeys,
                "Detected missed entries:");
    }

    private static void getPackagedThemeJsonContents(File jarFileToLookup,
            Map<String, JsonObject> packagedThemeHashes) {
        JarContentsManager jarContentsManager = new JarContentsManager();
        if (jarContentsManager.containsPath(jarFileToLookup,
                Constants.RESOURCES_THEME_JAR_DEFAULT)) {
            List<String> themeJsons = jarContentsManager.findFiles(
                    jarFileToLookup, Constants.RESOURCES_THEME_JAR_DEFAULT,
                    "theme.json");
            for (String themeJson : themeJsons) {
                byte[] byteContent = jarContentsManager
                        .getFileContents(jarFileToLookup, themeJson);
                String content = IOUtils.toString(byteContent, "UTF-8");
                content = content.replaceAll("\\r\\n", "\n");

                Matcher matcher = THEME_PATH_PATTERN.matcher(themeJson);
                if (!matcher.find()) {
                    throw new IllegalStateException(
                            "Packaged theme folders structure is incorrect, should have META-INF/resources/themes/[theme-name]/");
                }
                String themeName = matcher.group(1);
                JsonObject jsonContent = Json.parse(content);
                packagedThemeHashes.put(themeName, jsonContent);
            }
        }
    }

    private static Logger getLogger() {
        return LoggerFactory.getLogger(TaskRunDevBundleBuild.class);
    }

    private void runFrontendBuildTool(String toolName, String executable,
            Map<String, String> environment, String... params)
            throws ExecutionFailedException {
        Logger logger = getLogger();

        FrontendToolsSettings settings = new FrontendToolsSettings(
                options.getNpmFolder().getAbsolutePath(),
                () -> FrontendUtils.getVaadinHomeDirectory().getAbsolutePath());
        settings.setNodeDownloadRoot(options.getNodeDownloadRoot());
        settings.setForceAlternativeNode(options.isRequireHomeNodeExec());
        settings.setUseGlobalPnpm(options.isUseGlobalPnpm());
        settings.setAutoUpdate(options.isNodeAutoUpdate());
        settings.setNodeVersion(options.getNodeVersion());
        FrontendTools frontendTools = new FrontendTools(settings);

        File buildExecutable = new File(options.getNpmFolder(),
                "node_modules/" + executable);
        if (!buildExecutable.isFile()) {
            throw new IllegalStateException(String.format(
                    "Unable to locate %s executable by path '%s'. Double"
                            + " check that the plugin is executed correctly",
                    toolName, buildExecutable.getAbsolutePath()));
        }

        String nodePath;
        if (options.isRequireHomeNodeExec()) {
            nodePath = frontendTools.forceAlternativeNodeExecutable();
        } else {
            nodePath = frontendTools.getNodeExecutable();
        }

        List<String> command = new ArrayList<>();
        command.add(nodePath);
        command.add(buildExecutable.getAbsolutePath());
        command.addAll(Arrays.asList(params));

        String commandString = command.stream()
                .collect(Collectors.joining(" "));

        ProcessBuilder builder = FrontendUtils.createProcessBuilder(command);
        builder.environment().put("devBundle", "true");
        builder.environment().put("NODE_ENV", "development");

        Process process = null;
        try {
            builder.directory(options.getNpmFolder());
            builder.redirectInput(ProcessBuilder.Redirect.PIPE);
            builder.redirectErrorStream(true);

            process = builder.start();

            // This will allow to destroy the process which does IO regardless
            // whether it's executed in the same thread or another (may be
            // daemon) thread
            Runtime.getRuntime()
                    .addShutdownHook(new Thread(process::destroyForcibly));

            logger.debug("Output of `{}`:", commandString);
            StringBuilder toolOutput = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream(),
                            StandardCharsets.UTF_8))) {
                String stdoutLine;
                while ((stdoutLine = reader.readLine()) != null) {
                    logger.debug(stdoutLine);
                    toolOutput.append(stdoutLine)
                            .append(System.lineSeparator());
                }
            }

            int errorCode = process.waitFor();

            if (errorCode != 0) {
                logger.error("Command `{}` failed:\n{}", commandString,
                        toolOutput);
                throw new ExecutionFailedException(
                        SharedUtil.capitalize(toolName)
                                + " build exited with a non zero status");
            } else {
                logger.info("Development frontend bundle built");
            }
        } catch (InterruptedException | IOException e) {
            logger.error("Error when running `{}`", commandString, e);
            if (e instanceof InterruptedException) {
                // Restore interrupted state
                Thread.currentThread().interrupt();
            }
            throw new ExecutionFailedException(
                    "Command '" + commandString + "' failed to finish", e);
        } finally {
            if (process != null) {
                process.destroyForcibly();
            }
        }
    }

    private static boolean compareObjects(Collection<String> missedKeys,
            JsonObject jsonObjectFromBundle, JsonObject projectJsonObject) {
        boolean allEntriesFound = true;

        for (String projectEntryKey : projectJsonObject.keys()) {
            JsonValue projectEntry = projectJsonObject.get(projectEntryKey);
            // ignore parent theme, because having a parent theme doesn't
            // need a new bundle per se
            if (projectEntry.getType() == JsonType.STRING
                    && "parent".equals(projectEntryKey)) {
                continue;
            }
            boolean entryFound = false;
            for (String bundleEntryKey : jsonObjectFromBundle.keys()) {
                JsonValue bundleEntry = jsonObjectFromBundle
                        .get(bundleEntryKey);
                if (bundleEntry.getType() == projectEntry.getType()
                        && objectIncludesEntry(bundleEntry, projectEntry,
                                missedKeys)) {
                    entryFound = true;
                    break;
                }
            }
            if (!entryFound) {
                missedKeys.add(projectEntryKey);
            }
            allEntriesFound = allEntriesFound && entryFound;
        }
        return allEntriesFound;
    }

    private static boolean compareArrays(Collection<String> missedKeys,
            JsonArray jsonArrayFromBundle, JsonArray projectJsonArray) {
        boolean allEntriesFound = true;

        for (int projectArrayIndex = 0; projectArrayIndex < projectJsonArray
                .length(); projectArrayIndex++) {
            JsonValue projectArrayEntry = projectJsonArray
                    .get(projectArrayIndex);
            boolean entryFound = false;
            for (int bundleArrayIndex = 0; bundleArrayIndex < jsonArrayFromBundle
                    .length(); bundleArrayIndex++) {
                JsonValue bundleArrayEntry = jsonArrayFromBundle
                        .get(bundleArrayIndex);
                if (bundleArrayEntry.getType() == projectArrayEntry.getType()
                        && objectIncludesEntry(bundleArrayEntry,
                                projectArrayEntry, missedKeys)) {
                    entryFound = true;
                    break;
                }
            }
            if (!entryFound) {
                missedKeys.add(projectArrayEntry.toJson());
            }
            allEntriesFound = allEntriesFound && entryFound;
        }
        return allEntriesFound;
    }

    private void addReadme() {
        File devBundleFolder = new File(options.getNpmFolder(),
                Constants.DEV_BUNDLE_LOCATION);
        assert devBundleFolder.exists();

        try {
            File readme = new File(devBundleFolder, "README.md");
            boolean created = readme.createNewFile();
            if (created) {
                FileUtils.writeStringToFile(readme, README,
                        StandardCharsets.UTF_8);
            } else {
                getLogger().warn(README_NOT_CREATED);
            }
        } catch (Exception e) {
            getLogger().error(README_NOT_CREATED, e);
        }
    }
}
