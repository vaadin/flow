/*
 * Copyright 2000-2017 Vaadin Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.vaadin.flow.template.angular;

import java.io.Serializable;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

import com.vaadin.flow.StateNode;
import com.vaadin.flow.dom.Element;
import com.vaadin.shared.JsonConstants;

import elemental.json.Json;
import elemental.json.JsonArray;
import elemental.json.JsonObject;

/**
 * A node in the AST parsed from a template file. A template node is immutable.
 *
 * @author Vaadin Ltd
 */
public abstract class TemplateNode implements Serializable {
    /**
     * Key for the node type in JSON messages.
     */
    public static final String KEY_TYPE = "type";

    private static final AtomicInteger nextId = new AtomicInteger();

    private static final ConcurrentHashMap<Integer, TemplateNode> registry = new ConcurrentHashMap<>();

    private final int id = nextId.incrementAndGet();

    private final TemplateNode parent;

    /**
     * Creates a new template node with the given node as its parent.
     *
     * @param parent
     *            the parent of the new template node, or null if the node is
     *            the root of a template tree
     */
    public TemplateNode(TemplateNode parent) {
        this.parent = parent;

        registry.put(Integer.valueOf(id), this);
    }

    /**
     * Gets the parent node of this node.
     *
     * @return an optional parent node, or an empty optional if this node is the
     *         root of a template tree
     */
    public Optional<TemplateNode> getParent() {
        return Optional.ofNullable(parent);
    }

    /**
     * Gets the globally unique id of this template node. A node can be found
     * based on its id using {@link #get(int)}.
     *
     * @return the template node id
     */
    public int getId() {
        return id;
    }

    /**
     * Gets the number of child nodes.
     *
     * @return the number of child nodes
     */
    public abstract int getChildCount();

    /**
     * Gets the child node at the given index.
     *
     * @param index
     *            the child index
     * @return the child at the given index
     */
    public abstract TemplateNode getChild(int index);

    /**
     * Gets a node by its id.
     *
     * @see #getId()
     *
     * @param id
     *            the id of the node to get
     * @return the node with the given id, not <code>null</code>
     */
    public static TemplateNode get(int id) {
        assert has(id);

        return registry.get(Integer.valueOf(id));
    }

    /**
     * Checks whether a template node with the given id has been registered.
     *
     * @see #get(int)
     *
     * @param id
     *            the id to check
     * @return <code>true</code> if there is a template for the given id,
     *         <code>false</code> otherwise
     */
    public static boolean has(int id) {
        return registry.containsKey(Integer.valueOf(id));
    }

    /**
     * Encodes this node as JSON.
     *
     * @param childEncoder
     *            callback that makes sure a child template is made available to
     *            the client
     * @return a JSON object with the data for this node
     */
    public final JsonObject toJson(Consumer<TemplateNode> childEncoder) {
        JsonObject json = Json.createObject();

        // Let subclass encode its own data
        populateJson(json);

        assert json.hasKey(KEY_TYPE) : "updateJson must set " + KEY_TYPE;

        int childCount = getChildCount();
        if (childCount > 0) {
            JsonArray children = Json.createArray();

            for (int i = 0; i < childCount; i++) {
                TemplateNode child = getChild(i);
                childEncoder.accept(child);
                children.set(i, Json.create(child.getId()));
            }

            json.put(JsonConstants.CHILD_TEMPLATE_KEY, children);
        }

        return json;
    }

    /**
     * Gets the number of child elements generated by this node.
     *
     * @param templateStateNode
     *            the state node of the template for which elements are
     *            generated
     * @return the number of generated child elements
     */
    public abstract int getGeneratedElementCount(StateNode templateStateNode);

    /**
     * Generates an element by index.
     *
     * @param index
     *            the index of the element to generate
     * @param templateStateNode
     *            the state node of the template for which the element is
     *            generated
     * @return a generated element instance, not <code>null</code>
     */
    public abstract Element getElement(int index, StateNode templateStateNode);

    /**
     * Serializes data specific to a subclass to the provided JSON object. Must
     * also set the {@link #KEY_TYPE} property based on the template node type.
     *
     * @param json
     *            the JSON object to add data to, not <code>null</code>
     */
    protected abstract void populateJson(JsonObject json);

    /**
     * Gets the parent of a child element represented by the {@code node}.
     *
     * @param node
     *            the state node of a child element, not <code>null</code>
     * @return the parent element, not <code>null</code>
     */
    public abstract Element getParentElement(StateNode node);

    /**
     * Finds an element with the given id.
     * <p>
     * Nodes which generate multiple elements, e.g. *ngFor, are ignored by this
     * method.
     *
     * @param stateNode
     *            the template state node
     * @param id
     *            the id too look for
     * @return an optional element with the id, or an empty Optional if no
     *         element with the given id was found
     */
    public Optional<Element> findElement(StateNode stateNode, String id) {
        return Optional.empty();
    }

}
